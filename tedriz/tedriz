#!/usr/bin/env python3

import pygame
from typing import Tuple, List, Optional
import time
import random
import copy
import datetime


def get_color(shape: int):
    if shape == 0:
        return 255, 0, 0
    elif shape == 1:
        return 0, 255, 0
    elif shape == 2:
        return 0, 0, 255
    elif shape == 3:
        return 255, 255, 0
    elif shape == 4:
        return 255, 0, 255
    elif shape == 5:
        return 0, 255, 255
    elif shape == 6:
        return 255, 255, 255
    else:
        return 0, 0, 0


def draw_square(color: Tuple[int, int, int], coord: List[int], size: int, width: int = 2):
    pygame.draw.polygon(screen, color, [
        (coord[0], coord[1]),
        (coord[0] + size, coord[1]),
        (coord[0] + size, coord[1] + size),
        (coord[0], coord[1] + size)
    ], width)


def draw_piece(shape: int, rotation: int, coord: List[int], field_coord: Tuple[int, int], size: int, frame):
    color = get_color(shape)
    for y in range(0, 4):
        for x in range(0, 4):
            if shapes[shape][rotation] & (0x8000 >> (y * 4 + x)):
                draw_square(color, [(coord[0] + x) * size + field_coord[0], (coord[1] + y) * size + field_coord[1]], size)
    if frame:
        draw_square((100, 200, 100), [coord[0] * size + field_coord[0] - size, coord[1] * size + field_coord[1] - size], 5 * size)


def get_piece_matrix(shape: int, rotation: int) -> List[List[int]]:
    result: List[List[int]] = [[7] * 4 for _ in range(0, 4)]
    for y in range(0, 4):
        for x in range(0, 4):
            if shapes[shape][rotation] & (0x8000 >> (y * 4 + x)):
                result[y][x] = shape
    return result


def piece_field_intersects(coord: List[int], piece_matrix: List[List[int]], field: List[List[int]]):
    for py in range(0, 4):
        for px in range(0, 4):
            box_x = coord[0] + px
            box_y = coord[1] + py
            piece_shape = piece_matrix[py][px]
            if piece_shape == 7:
                continue
            if box_x > FIELD_WIDTH - 1:
                return True
            elif box_y > FIELD_HEIGHT - 1:
                return True
            elif box_x < 0:
                return True
            elif box_y < 0:
                return True
            field_shape = field[box_y][box_x]
            if field_shape < 7:
                return True
    return False


def add_piece_matrix_to_field(coord: List[int], piece_matrix: List[List[int]], field: List[List[int]]):
    for y in range(0, 4):
        for x in range(0, 4):
            piece_shape = piece_matrix[y][x]
            if piece_shape < 7:
                field[coord[1] + y][coord[0] + x] = piece_matrix[y][x]


def draw_field(field_coord: List[int], field: List[List[int]]):
    for y in range(0, FIELD_HEIGHT):
        for x in range(0, FIELD_WIDTH):
            if field[y][x] == 7:
                continue
            color = get_color(field[y][x])
            coord = [field_coord[0] + x * BLOCK_SIZE, field_coord[1] + y * BLOCK_SIZE]
            draw_square(color, coord, BLOCK_SIZE, 0)


def clear_field_lines(field: List[List[int]]):
    delete_count = 0
    copy_field = copy.copy(field)
    copy_field.reverse()
    for i, l in enumerate(copy_field):
        if all(e < 7 for e in l):
            del field[FIELD_HEIGHT - i - 1]
            delete_count += 1
    for _ in range(0, delete_count):
        field.insert(0, [7] * FIELD_WIDTH)

    return delete_count


shapes = [
    [0x4E00, 0x4C40, 0x0E40, 0x4640],  # 'T'
    [0x6C00, 0x8C40, 0x6C00, 0x8C40],  # 'S'
    [0xC600, 0x4C80, 0xC600, 0x4C80],  # 'Z'
    [0x0F00, 0x4444, 0x0F00, 0x4444],  # 'I'
    [0xE200, 0xC880, 0x8E00, 0x44C0],  # 'J'
    [0x2E00, 0xC440, 0xE800, 0x88C0],  # 'L'
    [0xCC00, 0xCC00, 0xCC00, 0xCC00]  # 'O'
]

VERSION = "0.0.1"
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 480
FIELD_WIDTH = 10
FIELD_HEIGHT = 20
pygame.init()
pygame.display.set_caption(f"tedriz {VERSION}")
pygame.display.set_icon(pygame.image.load("tedriz.png"))
pygame.font.init()
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

DROP_EVENT = pygame.USEREVENT
RIGHT_SCROLL_EVENT = pygame.USEREVENT + 1
LEFT_SCROLL_EVENT = pygame.USEREVENT + 2
RESET_PIECE = pygame.USEREVENT + 3
DOWN_SCROLL_EVENT = pygame.USEREVENT + 4
APM_EVENT = pygame.USEREVENT + 5
BLOCK_SIZE = 20


def generate_random_piece(future_shape: Optional[int] = None) -> Tuple[int, int, int, List[int], List[List[int]]]:
    new_shape = future_shape
    if new_shape is None:
        new_shape = random.randint(0, 6)
    next_shape = random.randint(0, 6)
    # reduce possibility of getting two of the same pieces in a row
    if new_shape == next_shape:
        next_shape = random.randint(0, 6)
    new_rotation = 0
    new_piece_position = [4, 0]
    new_piece_matrix = get_piece_matrix(new_shape, new_rotation)
    return new_shape, next_shape, new_rotation, new_piece_position, new_piece_matrix


score_font = pygame.font.SysFont('Comic Sans MS', 30)


class Game:
    def __init__(self):
        self.future_shape = None
        self.running = True
        self.lines = 0
        self.score = 0
        self.shape = 0
        self.rotation = 0
        self.piece_position = []
        self.piece_matrix = []
        self.paused = False
        self.speed_up = 50
        self.drop_wait = 500
        self.apm = 0
        self.state = "GAMING"
        self.action_count = 0
        self.start_time = datetime.datetime.now()
        self.field_coord = [int((SCREEN_WIDTH - FIELD_WIDTH * BLOCK_SIZE) / 2), BLOCK_SIZE]
        self.field: List[List[int]] = []
        self.start_game()

    def touchdown(self):
        add_piece_matrix_to_field(self.piece_position, self.piece_matrix, self.field)
        prev_lines = self.lines
        self.lines += clear_field_lines(self.field)
        self.score += (self.lines - prev_lines) ** 2
        if self.lines // 10 > prev_lines // 10:
            self.drop_wait -= self.speed_up
            pygame.time.set_timer(DROP_EVENT, self.drop_wait)
        self.shape, self.future_shape, self.rotation, self.piece_position, self.piece_matrix = generate_random_piece(self.future_shape)

    def start_game(self):
        self.running = True
        self.lines = 0
        self.score = 0
        self.action_count = 0
        self.drop_wait = 500
        self.apm = 0
        self.state = "GAMING"
        self.field: List[List[int]] = [[7] * FIELD_WIDTH for _ in range(0, FIELD_HEIGHT)]
        self.shape, self.future_shape, self.rotation, self.piece_position, self.piece_matrix = generate_random_piece(self.future_shape)
        self.start_time = datetime.datetime.now()
        pygame.time.set_timer(DROP_EVENT, self.drop_wait)
        pygame.time.set_timer(APM_EVENT, 500)
        pygame.time.set_timer(DOWN_SCROLL_EVENT, 0)
        pygame.time.set_timer(RIGHT_SCROLL_EVENT, 0)
        pygame.time.set_timer(LEFT_SCROLL_EVENT, 0)

    def move_piece_left(self) -> bool:
        if self.paused:
            return False
        if piece_field_intersects([self.piece_position[0] - 1, self.piece_position[1]], self.piece_matrix, self.field):
            return False
        self.piece_position[0] -= 1
        return True

    def move_piece_right(self) -> bool:
        if self.paused:
            return False
        if piece_field_intersects([self.piece_position[0] + 1, self.piece_position[1]], self.piece_matrix, self.field):
            return False
        self.piece_position[0] += 1
        return True

    def move_piece_down(self) -> bool:
        if self.paused:
            return True
        if piece_field_intersects([self.piece_position[0], self.piece_position[1] + 1], self.piece_matrix, self.field):
            return False
        self.piece_position[1] += 1
        return True

    def check_piece_rotation(self) -> bool:
        if self.paused:
            return False
        next_rotation = self.rotation + 1
        if next_rotation > 3:
            next_rotation = 0
        if piece_field_intersects(self.piece_position, get_piece_matrix(self.shape, next_rotation), self.field):
            return False
        return True

    def render_gaming_screen(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False

            elif event.type == pygame.KEYDOWN:
                self.action_count += 1
                if event.key == pygame.K_UP:
                    if self.check_piece_rotation():
                        self.rotation += 1
                        if self.rotation > 3:
                            self.rotation = 0
                        self.piece_matrix = get_piece_matrix(self.shape, self.rotation)
                elif event.key == pygame.K_LEFT:
                    self.move_piece_left()
                    pygame.time.set_timer(LEFT_SCROLL_EVENT, 80)
                elif event.key == pygame.K_RIGHT:
                    self.move_piece_right()
                    pygame.time.set_timer(RIGHT_SCROLL_EVENT, 80)
                elif event.key == pygame.K_DOWN:
                    if not self.move_piece_down():
                        self.touchdown()
                        continue
                    pygame.time.set_timer(DOWN_SCROLL_EVENT, 50)
                elif event.key == pygame.K_p:
                    self.paused = not self.paused
            elif event.type == pygame.KEYUP:
                if event.key == pygame.K_LEFT:
                    pygame.time.set_timer(LEFT_SCROLL_EVENT, 0)
                elif event.key == pygame.K_RIGHT:
                    pygame.time.set_timer(RIGHT_SCROLL_EVENT, 0)
                elif event.key == pygame.K_DOWN:
                    pygame.time.set_timer(DOWN_SCROLL_EVENT, 0)

            elif event.type == DOWN_SCROLL_EVENT or event.type == DROP_EVENT:
                if not self.move_piece_down():
                    if self.piece_position[1] == 0:
                        self.state = "GAMEOVER"
                        return
                    self.touchdown()
            elif event.type == LEFT_SCROLL_EVENT:
                self.move_piece_left()
            elif event.type == RIGHT_SCROLL_EVENT:
                self.move_piece_right()
            elif event.type == APM_EVENT:
                self.apm = int(self.action_count / ((datetime.datetime.now() - self.start_time).total_seconds() / 60))

        screen.fill((0, 0, 0))
        draw_field(self.field_coord, self.field)
        pygame.draw.rect(screen, (0, 255, 0), [tuple(self.field_coord), (FIELD_WIDTH * BLOCK_SIZE, FIELD_HEIGHT * BLOCK_SIZE)], 2)
        draw_piece(self.shape, self.rotation, self.piece_position, (self.field_coord[0], self.field_coord[1]), BLOCK_SIZE, False)
        draw_piece(self.future_shape, 0, [15, 10], (self.field_coord[0], self.field_coord[1]), BLOCK_SIZE, True)
        if self.paused:
            score_image = score_font.render(f"Skor: {self.score} (PAUSED)", True, (255, 255, 255))
        else:
            score_image = score_font.render(f"Skor: {self.score}", True, (255, 255, 255))
        screen.blit(score_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2)))
        lines_image = score_font.render(f"Satır: {self.lines}", True, (255, 255, 255))
        screen.blit(lines_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2) + 25))
        apm_image = score_font.render(f"APM: {self.apm}", True, (255, 255, 255))
        screen.blit(apm_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2) + 50))

    def render_gameover_screen(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_y:
                    self.start_game()
                    return
                elif event.key == pygame.K_n:
                    self.running = False
                    return
        screen.fill((0, 0, 0))
        question_image = score_font.render(f"Game over. Continue? (y/n)", True, (255, 255, 255))
        screen.blit(question_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 3), int(SCREEN_HEIGHT / 2)))
        if self.paused:
            score_image = score_font.render(f"Skor: {self.score} (PAUSED)", True, (255, 255, 255))
        else:
            score_image = score_font.render(f"Skor: {self.score}", True, (255, 255, 255))
        screen.blit(score_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2)))
        lines_image = score_font.render(f"Satır: {self.lines}", True, (255, 255, 255))
        screen.blit(lines_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2) + 25))
        apm_image = score_font.render(f"APM: {self.apm}", True, (255, 255, 255))
        screen.blit(apm_image, (int((SCREEN_WIDTH - FIELD_WIDTH) / 16), int(SCREEN_HEIGHT / 2) + 50))

    def run(self):
        while self.running:
            if self.state == "GAMING":
                self.render_gaming_screen()
            elif self.state == "GAMEOVER":
                self.render_gameover_screen()
            time.sleep(0.01)
            pygame.display.flip()


if __name__ == "__main__":
    try:
        Game().run()
    except KeyboardInterrupt:
        print("BYEBYE")
